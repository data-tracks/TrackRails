// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protocol {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CREATE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CREATE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CREATE_TYPE: [CreateType; 2] = [
  CreateType::NONE,
  CreateType::CreatePlanRequest,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CreateType(pub u8);
#[allow(non_upper_case_globals)]
impl CreateType {
  pub const NONE: Self = Self(0);
  pub const CreatePlanRequest: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CreatePlanRequest,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CreatePlanRequest => Some("CreatePlanRequest"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CreateType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CreateType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CreateType {
    type Output = CreateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CreateType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CreateType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CreateType {}
pub struct CreateTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FILTER_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FILTER_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FILTER_TYPE: [FilterType; 2] = [
  FilterType::NONE,
  FilterType::ByName,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FilterType(pub u8);
#[allow(non_upper_case_globals)]
impl FilterType {
  pub const NONE: Self = Self(0);
  pub const ByName: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ByName,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ByName => Some("ByName"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FilterType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FilterType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FilterType {
    type Output = FilterType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FilterType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FilterType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FilterType {}
pub struct FilterTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GET_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GET_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GET_TYPE: [GetType; 3] = [
  GetType::NONE,
  GetType::GetPlans,
  GetType::GetPlan,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GetType(pub u8);
#[allow(non_upper_case_globals)]
impl GetType {
  pub const NONE: Self = Self(0);
  pub const GetPlans: Self = Self(1);
  pub const GetPlan: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GetPlans,
    Self::GetPlan,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GetPlans => Some("GetPlans"),
      Self::GetPlan => Some("GetPlan"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GetType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GetType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GetType {
    type Output = GetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GetType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GetType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GetType {}
pub struct GetTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRANSFORM_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRANSFORM_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSFORM_TYPE: [TransformType; 2] = [
  TransformType::NONE,
  TransformType::LanguageTransform,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TransformType(pub u8);
#[allow(non_upper_case_globals)]
impl TransformType {
  pub const NONE: Self = Self(0);
  pub const LanguageTransform: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::LanguageTransform,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::LanguageTransform => Some("LanguageTransform"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TransformType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TransformType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TransformType {
    type Output = TransformType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TransformType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TransformType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TransformType {}
pub struct TransformTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLAN_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLAN_STATUS: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAN_STATUS: [PlanStatus; 3] = [
  PlanStatus::Running,
  PlanStatus::Stopped,
  PlanStatus::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlanStatus(pub i8);
#[allow(non_upper_case_globals)]
impl PlanStatus {
  pub const Running: Self = Self(0);
  pub const Stopped: Self = Self(1);
  pub const Error: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Running,
    Self::Stopped,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Running => Some("Running"),
      Self::Stopped => Some("Stopped"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PlanStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PlanStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PlanStatus {
    type Output = PlanStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlanStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PlanStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PlanStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALUE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALUE: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE: [Value; 9] = [
  Value::NONE,
  Value::Null,
  Value::Text,
  Value::Bool,
  Value::Integer,
  Value::Float,
  Value::List,
  Value::Document,
  Value::Time,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Value(pub u8);
#[allow(non_upper_case_globals)]
impl Value {
  pub const NONE: Self = Self(0);
  pub const Null: Self = Self(1);
  pub const Text: Self = Self(2);
  pub const Bool: Self = Self(3);
  pub const Integer: Self = Self(4);
  pub const Float: Self = Self(5);
  pub const List: Self = Self(6);
  pub const Document: Self = Self(7);
  pub const Time: Self = Self(8);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Null,
    Self::Text,
    Self::Bool,
    Self::Integer,
    Self::Float,
    Self::List,
    Self::Document,
    Self::Time,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Null => Some("Null"),
      Self::Text => Some("Text"),
      Self::Bool => Some("Bool"),
      Self::Integer => Some("Integer"),
      Self::Float => Some("Float"),
      Self::List => Some("List"),
      Self::Document => Some("Document"),
      Self::Time => Some("Time"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Value {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Value {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Value {
    type Output = Value;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Value {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Value {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Value {}
pub struct ValueUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATUS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATUS: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATUS: [Status; 3] = [
  Status::NONE,
  Status::OkStatus,
  Status::ErrorStatus,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Status(pub u8);
#[allow(non_upper_case_globals)]
impl Status {
  pub const NONE: Self = Self(0);
  pub const OkStatus: Self = Self(1);
  pub const ErrorStatus: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::OkStatus,
    Self::ErrorStatus,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::OkStatus => Some("OkStatus"),
      Self::ErrorStatus => Some("ErrorStatus"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Status {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Status {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Status {
    type Output = Status;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Status {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Status {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Status {}
pub struct StatusUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PAYLOAD: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAYLOAD: [Payload; 11] = [
  Payload::NONE,
  Payload::Create,
  Payload::Get,
  Payload::Train,
  Payload::Catalog,
  Payload::RegisterRequest,
  Payload::RegisterResponse,
  Payload::BindRequest,
  Payload::BindResponse,
  Payload::UnbindRequest,
  Payload::UnbindResponse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Payload(pub u8);
#[allow(non_upper_case_globals)]
impl Payload {
  pub const NONE: Self = Self(0);
  pub const Create: Self = Self(1);
  pub const Get: Self = Self(2);
  pub const Train: Self = Self(3);
  pub const Catalog: Self = Self(4);
  pub const RegisterRequest: Self = Self(5);
  pub const RegisterResponse: Self = Self(6);
  pub const BindRequest: Self = Self(7);
  pub const BindResponse: Self = Self(8);
  pub const UnbindRequest: Self = Self(9);
  pub const UnbindResponse: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Create,
    Self::Get,
    Self::Train,
    Self::Catalog,
    Self::RegisterRequest,
    Self::RegisterResponse,
    Self::BindRequest,
    Self::BindResponse,
    Self::UnbindRequest,
    Self::UnbindResponse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Create => Some("Create"),
      Self::Get => Some("Get"),
      Self::Train => Some("Train"),
      Self::Catalog => Some("Catalog"),
      Self::RegisterRequest => Some("RegisterRequest"),
      Self::RegisterResponse => Some("RegisterResponse"),
      Self::BindRequest => Some("BindRequest"),
      Self::BindResponse => Some("BindResponse"),
      Self::UnbindRequest => Some("UnbindRequest"),
      Self::UnbindResponse => Some("UnbindResponse"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Payload {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Payload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Payload {
    type Output = Payload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Payload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Payload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Payload {}
pub struct PayloadUnionTableOffset {}

pub enum RegisterResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RegisterResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RegisterResponse<'a> {
  type Inner = RegisterResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RegisterResponse<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CATALOG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RegisterResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RegisterResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<RegisterResponse<'bldr>> {
    let mut builder = RegisterResponseBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.catalog { builder.add_catalog(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RegisterResponse::VT_ID, None)}
  }
  #[inline]
  pub fn catalog(&self) -> Option<Catalog<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Catalog>>(RegisterResponse::VT_CATALOG, None)}
  }
}

impl flatbuffers::Verifiable for RegisterResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Catalog>>("catalog", Self::VT_CATALOG, false)?
     .finish();
    Ok(())
  }
}
pub struct RegisterResponseArgs<'a> {
    pub id: Option<u64>,
    pub catalog: Option<flatbuffers::WIPOffset<Catalog<'a>>>,
}
impl<'a> Default for RegisterResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    RegisterResponseArgs {
      id: None,
      catalog: None,
    }
  }
}

pub struct RegisterResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RegisterResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot_always::<u64>(RegisterResponse::VT_ID, id);
  }
  #[inline]
  pub fn add_catalog(&mut self, catalog: flatbuffers::WIPOffset<Catalog<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Catalog>>(RegisterResponse::VT_CATALOG, catalog);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RegisterResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RegisterResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RegisterResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RegisterResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RegisterResponse");
      ds.field("id", &self.id());
      ds.field("catalog", &self.catalog());
      ds.finish()
  }
}
pub enum RegisterRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RegisterRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RegisterRequest<'a> {
  type Inner = RegisterRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RegisterRequest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CATALOG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RegisterRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RegisterRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<RegisterRequest<'bldr>> {
    let mut builder = RegisterRequestBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.catalog { builder.add_catalog(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RegisterRequest::VT_ID, None)}
  }
  #[inline]
  pub fn catalog(&self) -> Option<Catalog<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Catalog>>(RegisterRequest::VT_CATALOG, None)}
  }
}

impl flatbuffers::Verifiable for RegisterRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Catalog>>("catalog", Self::VT_CATALOG, false)?
     .finish();
    Ok(())
  }
}
pub struct RegisterRequestArgs<'a> {
    pub id: Option<u64>,
    pub catalog: Option<flatbuffers::WIPOffset<Catalog<'a>>>,
}
impl<'a> Default for RegisterRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RegisterRequestArgs {
      id: None,
      catalog: None,
    }
  }
}

pub struct RegisterRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RegisterRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot_always::<u64>(RegisterRequest::VT_ID, id);
  }
  #[inline]
  pub fn add_catalog(&mut self, catalog: flatbuffers::WIPOffset<Catalog<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Catalog>>(RegisterRequest::VT_CATALOG, catalog);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RegisterRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RegisterRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RegisterRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RegisterRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RegisterRequest");
      ds.field("id", &self.id());
      ds.field("catalog", &self.catalog());
      ds.finish()
  }
}
pub enum CreateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Create<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Create<'a> {
  type Inner = Create<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Create<'a> {
  pub const VT_CREATE_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CREATE_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Create { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateArgs
  ) -> flatbuffers::WIPOffset<Create<'bldr>> {
    let mut builder = CreateBuilder::new(_fbb);
    if let Some(x) = args.create_type { builder.add_create_type(x); }
    builder.add_create_type_type(args.create_type_type);
    builder.finish()
  }


  #[inline]
  pub fn create_type_type(&self) -> CreateType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CreateType>(Create::VT_CREATE_TYPE_TYPE, Some(CreateType::NONE)).unwrap()}
  }
  #[inline]
  pub fn create_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Create::VT_CREATE_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn create_type_as_create_plan_request(&self) -> Option<CreatePlanRequest<'a>> {
    if self.create_type_type() == CreateType::CreatePlanRequest {
      self.create_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreatePlanRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Create<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<CreateType, _>("create_type_type", Self::VT_CREATE_TYPE_TYPE, "create_type", Self::VT_CREATE_TYPE, false, |key, v, pos| {
        match key {
          CreateType::CreatePlanRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreatePlanRequest>>("CreateType::CreatePlanRequest", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct CreateArgs {
    pub create_type_type: CreateType,
    pub create_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CreateArgs {
  #[inline]
  fn default() -> Self {
    CreateArgs {
      create_type_type: CreateType::NONE,
      create_type: None,
    }
  }
}

pub struct CreateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_create_type_type(&mut self, create_type_type: CreateType) {
    self.fbb_.push_slot::<CreateType>(Create::VT_CREATE_TYPE_TYPE, create_type_type, CreateType::NONE);
  }
  #[inline]
  pub fn add_create_type(&mut self, create_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Create::VT_CREATE_TYPE, create_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Create<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Create<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Create");
      ds.field("create_type_type", &self.create_type_type());
      match self.create_type_type() {
        CreateType::CreatePlanRequest => {
          if let Some(x) = self.create_type_as_create_plan_request() {
            ds.field("create_type", &x)
          } else {
            ds.field("create_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("create_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum CreatePlanRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreatePlanRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreatePlanRequest<'a> {
  type Inner = CreatePlanRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreatePlanRequest<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PLAN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreatePlanRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreatePlanRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CreatePlanRequest<'bldr>> {
    let mut builder = CreatePlanRequestBuilder::new(_fbb);
    if let Some(x) = args.plan { builder.add_plan(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreatePlanRequest::VT_NAME, None)}
  }
  #[inline]
  pub fn plan(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreatePlanRequest::VT_PLAN, None)}
  }
}

impl flatbuffers::Verifiable for CreatePlanRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plan", Self::VT_PLAN, false)?
     .finish();
    Ok(())
  }
}
pub struct CreatePlanRequestArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plan: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreatePlanRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreatePlanRequestArgs {
      name: None,
      plan: None,
    }
  }
}

pub struct CreatePlanRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreatePlanRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreatePlanRequest::VT_NAME, name);
  }
  #[inline]
  pub fn add_plan(&mut self, plan: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreatePlanRequest::VT_PLAN, plan);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreatePlanRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreatePlanRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreatePlanRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreatePlanRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreatePlanRequest");
      ds.field("name", &self.name());
      ds.field("plan", &self.plan());
      ds.finish()
  }
}
pub enum CreatePlanResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreatePlanResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreatePlanResponse<'a> {
  type Inner = CreatePlanResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreatePlanResponse<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PLAN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreatePlanResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreatePlanResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<CreatePlanResponse<'bldr>> {
    let mut builder = CreatePlanResponseBuilder::new(_fbb);
    if let Some(x) = args.plan { builder.add_plan(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreatePlanResponse::VT_NAME, None)}
  }
  #[inline]
  pub fn plan(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreatePlanResponse::VT_PLAN, None)}
  }
}

impl flatbuffers::Verifiable for CreatePlanResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plan", Self::VT_PLAN, false)?
     .finish();
    Ok(())
  }
}
pub struct CreatePlanResponseArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plan: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreatePlanResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreatePlanResponseArgs {
      name: None,
      plan: None,
    }
  }
}

pub struct CreatePlanResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreatePlanResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreatePlanResponse::VT_NAME, name);
  }
  #[inline]
  pub fn add_plan(&mut self, plan: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreatePlanResponse::VT_PLAN, plan);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreatePlanResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreatePlanResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreatePlanResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreatePlanResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreatePlanResponse");
      ds.field("name", &self.name());
      ds.field("plan", &self.plan());
      ds.finish()
  }
}
pub enum ByNameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ByName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ByName<'a> {
  type Inner = ByName<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ByName<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ByName { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ByNameArgs<'args>
  ) -> flatbuffers::WIPOffset<ByName<'bldr>> {
    let mut builder = ByNameBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ByName::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for ByName<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct ByNameArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ByNameArgs<'a> {
  #[inline]
  fn default() -> Self {
    ByNameArgs {
      name: None,
    }
  }
}

pub struct ByNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ByNameBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ByName::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ByNameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ByNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ByName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ByName<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ByName");
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum FilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Filter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Filter<'a> {
  type Inner = Filter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Filter<'a> {
  pub const VT_FILTER_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_FILTER_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Filter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FilterArgs
  ) -> flatbuffers::WIPOffset<Filter<'bldr>> {
    let mut builder = FilterBuilder::new(_fbb);
    if let Some(x) = args.filter_type { builder.add_filter_type(x); }
    builder.add_filter_type_type(args.filter_type_type);
    builder.finish()
  }


  #[inline]
  pub fn filter_type_type(&self) -> FilterType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FilterType>(Filter::VT_FILTER_TYPE_TYPE, Some(FilterType::NONE)).unwrap()}
  }
  #[inline]
  pub fn filter_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Filter::VT_FILTER_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn filter_type_as_by_name(&self) -> Option<ByName<'a>> {
    if self.filter_type_type() == FilterType::ByName {
      self.filter_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ByName::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Filter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<FilterType, _>("filter_type_type", Self::VT_FILTER_TYPE_TYPE, "filter_type", Self::VT_FILTER_TYPE, false, |key, v, pos| {
        match key {
          FilterType::ByName => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ByName>>("FilterType::ByName", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct FilterArgs {
    pub filter_type_type: FilterType,
    pub filter_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FilterArgs {
  #[inline]
  fn default() -> Self {
    FilterArgs {
      filter_type_type: FilterType::NONE,
      filter_type: None,
    }
  }
}

pub struct FilterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FilterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_filter_type_type(&mut self, filter_type_type: FilterType) {
    self.fbb_.push_slot::<FilterType>(Filter::VT_FILTER_TYPE_TYPE, filter_type_type, FilterType::NONE);
  }
  #[inline]
  pub fn add_filter_type(&mut self, filter_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Filter::VT_FILTER_TYPE, filter_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FilterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Filter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Filter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Filter");
      ds.field("filter_type_type", &self.filter_type_type());
      match self.filter_type_type() {
        FilterType::ByName => {
          if let Some(x) = self.filter_type_as_by_name() {
            ds.field("filter_type", &x)
          } else {
            ds.field("filter_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("filter_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum GetPlansOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPlans<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPlans<'a> {
  type Inner = GetPlans<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetPlans<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetPlans { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetPlansArgs<'args>
  ) -> flatbuffers::WIPOffset<GetPlans<'bldr>> {
    let mut builder = GetPlansBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<Filter<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Filter>>(GetPlans::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for GetPlans<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Filter>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct GetPlansArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<Filter<'a>>>,
}
impl<'a> Default for GetPlansArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetPlansArgs {
      name: None,
    }
  }
}

pub struct GetPlansBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetPlansBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<Filter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Filter>>(GetPlans::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetPlansBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetPlansBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPlans<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetPlans<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetPlans");
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum GetPlanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPlan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPlan<'a> {
  type Inner = GetPlan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetPlan<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetPlan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetPlanArgs
  ) -> flatbuffers::WIPOffset<GetPlan<'bldr>> {
    let mut builder = GetPlanBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GetPlan::VT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetPlan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GetPlanArgs {
    pub id: u64,
}
impl<'a> Default for GetPlanArgs {
  #[inline]
  fn default() -> Self {
    GetPlanArgs {
      id: 0,
    }
  }
}

pub struct GetPlanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetPlanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(GetPlan::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetPlanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetPlanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPlan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetPlan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetPlan");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum GetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Get<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Get<'a> {
  type Inner = Get<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Get<'a> {
  pub const VT_GET_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_GET_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Get { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetArgs
  ) -> flatbuffers::WIPOffset<Get<'bldr>> {
    let mut builder = GetBuilder::new(_fbb);
    if let Some(x) = args.get_type { builder.add_get_type(x); }
    builder.add_get_type_type(args.get_type_type);
    builder.finish()
  }


  #[inline]
  pub fn get_type_type(&self) -> GetType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GetType>(Get::VT_GET_TYPE_TYPE, Some(GetType::NONE)).unwrap()}
  }
  #[inline]
  pub fn get_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Get::VT_GET_TYPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn get_type_as_get_plans(&self) -> Option<GetPlans<'a>> {
    if self.get_type_type() == GetType::GetPlans {
      self.get_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetPlans::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn get_type_as_get_plan(&self) -> Option<GetPlan<'a>> {
    if self.get_type_type() == GetType::GetPlan {
      self.get_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetPlan::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Get<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<GetType, _>("get_type_type", Self::VT_GET_TYPE_TYPE, "get_type", Self::VT_GET_TYPE, false, |key, v, pos| {
        match key {
          GetType::GetPlans => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetPlans>>("GetType::GetPlans", pos),
          GetType::GetPlan => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetPlan>>("GetType::GetPlan", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct GetArgs {
    pub get_type_type: GetType,
    pub get_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GetArgs {
  #[inline]
  fn default() -> Self {
    GetArgs {
      get_type_type: GetType::NONE,
      get_type: None,
    }
  }
}

pub struct GetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_get_type_type(&mut self, get_type_type: GetType) {
    self.fbb_.push_slot::<GetType>(Get::VT_GET_TYPE_TYPE, get_type_type, GetType::NONE);
  }
  #[inline]
  pub fn add_get_type(&mut self, get_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Get::VT_GET_TYPE, get_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Get<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Get<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Get");
      ds.field("get_type_type", &self.get_type_type());
      match self.get_type_type() {
        GetType::GetPlans => {
          if let Some(x) = self.get_type_as_get_plans() {
            ds.field("get_type", &x)
          } else {
            ds.field("get_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GetType::GetPlan => {
          if let Some(x) = self.get_type_as_get_plan() {
            ds.field("get_type", &x)
          } else {
            ds.field("get_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("get_type", &x)
        },
      };
      ds.finish()
  }
}
pub enum CatalogOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Catalog<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Catalog<'a> {
  type Inner = Catalog<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Catalog<'a> {
  pub const VT_PLANS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Catalog { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CatalogArgs<'args>
  ) -> flatbuffers::WIPOffset<Catalog<'bldr>> {
    let mut builder = CatalogBuilder::new(_fbb);
    if let Some(x) = args.plans { builder.add_plans(x); }
    builder.finish()
  }


  #[inline]
  pub fn plans(&self) -> Option<Plans<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Plans>>(Catalog::VT_PLANS, None)}
  }
}

impl flatbuffers::Verifiable for Catalog<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Plans>>("plans", Self::VT_PLANS, false)?
     .finish();
    Ok(())
  }
}
pub struct CatalogArgs<'a> {
    pub plans: Option<flatbuffers::WIPOffset<Plans<'a>>>,
}
impl<'a> Default for CatalogArgs<'a> {
  #[inline]
  fn default() -> Self {
    CatalogArgs {
      plans: None,
    }
  }
}

pub struct CatalogBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CatalogBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plans(&mut self, plans: flatbuffers::WIPOffset<Plans<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Plans>>(Catalog::VT_PLANS, plans);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CatalogBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CatalogBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Catalog<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Catalog<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Catalog");
      ds.field("plans", &self.plans());
      ds.finish()
  }
}
pub enum StationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Station<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Station<'a> {
  type Inner = Station<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Station<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STOP: flatbuffers::VOffsetT = 6;
  pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;
  pub const VT_BLOCK: flatbuffers::VOffsetT = 10;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Station { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StationArgs<'args>
  ) -> flatbuffers::WIPOffset<Station<'bldr>> {
    let mut builder = StationBuilder::new(_fbb);
    builder.add_stop(args.stop);
    builder.add_id(args.id);
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.block { builder.add_block(x); }
    if let Some(x) = args.transform { builder.add_transform(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Station::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stop(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Station::VT_STOP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn transform(&self) -> Option<Transform<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Transform>>(Station::VT_TRANSFORM, None)}
  }
  #[inline]
  pub fn block(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Station::VT_BLOCK, None)}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Station::VT_INPUTS, None)}
  }
}

impl flatbuffers::Verifiable for Station<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<u64>("stop", Self::VT_STOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Transform>>("transform", Self::VT_TRANSFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("block", Self::VT_BLOCK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("inputs", Self::VT_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct StationArgs<'a> {
    pub id: u64,
    pub stop: u64,
    pub transform: Option<flatbuffers::WIPOffset<Transform<'a>>>,
    pub block: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for StationArgs<'a> {
  #[inline]
  fn default() -> Self {
    StationArgs {
      id: 0,
      stop: 0,
      transform: None,
      block: None,
      inputs: None,
    }
  }
}

pub struct StationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Station::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_stop(&mut self, stop: u64) {
    self.fbb_.push_slot::<u64>(Station::VT_STOP, stop, 0);
  }
  #[inline]
  pub fn add_transform(&mut self, transform: flatbuffers::WIPOffset<Transform<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transform>>(Station::VT_TRANSFORM, transform);
  }
  #[inline]
  pub fn add_block(&mut self, block: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Station::VT_BLOCK, block);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Station::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Station<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Station<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Station");
      ds.field("id", &self.id());
      ds.field("stop", &self.stop());
      ds.field("transform", &self.transform());
      ds.field("block", &self.block());
      ds.field("inputs", &self.inputs());
      ds.finish()
  }
}
pub enum LanguageTransformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LanguageTransform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LanguageTransform<'a> {
  type Inner = LanguageTransform<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LanguageTransform<'a> {
  pub const VT_LANGUAGE: flatbuffers::VOffsetT = 4;
  pub const VT_QUERY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LanguageTransform { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LanguageTransformArgs<'args>
  ) -> flatbuffers::WIPOffset<LanguageTransform<'bldr>> {
    let mut builder = LanguageTransformBuilder::new(_fbb);
    if let Some(x) = args.query { builder.add_query(x); }
    if let Some(x) = args.language { builder.add_language(x); }
    builder.finish()
  }


  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LanguageTransform::VT_LANGUAGE, None)}
  }
  #[inline]
  pub fn query(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LanguageTransform::VT_QUERY, None)}
  }
}

impl flatbuffers::Verifiable for LanguageTransform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
     .finish();
    Ok(())
  }
}
pub struct LanguageTransformArgs<'a> {
    pub language: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LanguageTransformArgs<'a> {
  #[inline]
  fn default() -> Self {
    LanguageTransformArgs {
      language: None,
      query: None,
    }
  }
}

pub struct LanguageTransformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LanguageTransformBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_language(&mut self, language: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LanguageTransform::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LanguageTransform::VT_QUERY, query);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LanguageTransformBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LanguageTransformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LanguageTransform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LanguageTransform<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LanguageTransform");
      ds.field("language", &self.language());
      ds.field("query", &self.query());
      ds.finish()
  }
}
pub enum TransformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Transform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transform<'a> {
  type Inner = Transform<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Transform<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Transform { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransformArgs<'args>
  ) -> flatbuffers::WIPOffset<Transform<'bldr>> {
    let mut builder = TransformBuilder::new(_fbb);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_type_type(args.type_type);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Transform::VT_NAME, None)}
  }
  #[inline]
  pub fn type_type(&self) -> TransformType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TransformType>(Transform::VT_TYPE_TYPE, Some(TransformType::NONE)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Transform::VT_TYPE_, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn type__as_language_transform(&self) -> Option<LanguageTransform<'a>> {
    if self.type_type() == TransformType::LanguageTransform {
      self.type_().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LanguageTransform::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Transform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_union::<TransformType, _>("type_type", Self::VT_TYPE_TYPE, "type_", Self::VT_TYPE_, false, |key, v, pos| {
        match key {
          TransformType::LanguageTransform => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LanguageTransform>>("TransformType::LanguageTransform", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct TransformArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_type: TransformType,
    pub type_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for TransformArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransformArgs {
      name: None,
      type_type: TransformType::NONE,
      type_: None,
    }
  }
}

pub struct TransformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transform::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_type(&mut self, type_type: TransformType) {
    self.fbb_.push_slot::<TransformType>(Transform::VT_TYPE_TYPE, type_type, TransformType::NONE);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transform::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransformBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Transform<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Transform");
      ds.field("name", &self.name());
      ds.field("type_type", &self.type_type());
      match self.type_type() {
        TransformType::LanguageTransform => {
          if let Some(x) = self.type__as_language_transform() {
            ds.field("type_", &x)
          } else {
            ds.field("type_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("type_", &x)
        },
      };
      ds.finish()
  }
}
pub enum KeyValueU64VecU64Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValueU64VecU64<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValueU64VecU64<'a> {
  type Inner = KeyValueU64VecU64<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValueU64VecU64<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValueU64VecU64 { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueU64VecU64Args<'args>
  ) -> flatbuffers::WIPOffset<KeyValueU64VecU64<'bldr>> {
    let mut builder = KeyValueU64VecU64Builder::new(_fbb);
    builder.add_key(args.key);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(KeyValueU64VecU64::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(KeyValueU64VecU64::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for KeyValueU64VecU64<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueU64VecU64Args<'a> {
    pub key: u64,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for KeyValueU64VecU64Args<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueU64VecU64Args {
      key: 0,
      value: None,
    }
  }
}

pub struct KeyValueU64VecU64Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueU64VecU64Builder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: u64) {
    self.fbb_.push_slot::<u64>(KeyValueU64VecU64::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValueU64VecU64::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueU64VecU64Builder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueU64VecU64Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValueU64VecU64<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValueU64VecU64<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValueU64VecU64");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum KeyValueU64StationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValueU64Station<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValueU64Station<'a> {
  type Inner = KeyValueU64Station<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValueU64Station<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValueU64Station { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueU64StationArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValueU64Station<'bldr>> {
    let mut builder = KeyValueU64StationBuilder::new(_fbb);
    builder.add_key(args.key);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(KeyValueU64Station::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<Station<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Station>>(KeyValueU64Station::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for KeyValueU64Station<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Station>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueU64StationArgs<'a> {
    pub key: u64,
    pub value: Option<flatbuffers::WIPOffset<Station<'a>>>,
}
impl<'a> Default for KeyValueU64StationArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueU64StationArgs {
      key: 0,
      value: None,
    }
  }
}

pub struct KeyValueU64StationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueU64StationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: u64) {
    self.fbb_.push_slot::<u64>(KeyValueU64Station::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Station<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Station>>(KeyValueU64Station::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueU64StationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueU64StationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValueU64Station<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValueU64Station<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValueU64Station");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum KeyValueStringTransformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValueStringTransform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValueStringTransform<'a> {
  type Inner = KeyValueStringTransform<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValueStringTransform<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValueStringTransform { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueStringTransformArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValueStringTransform<'bldr>> {
    let mut builder = KeyValueStringTransformBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValueStringTransform::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Transform<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Transform>>(KeyValueStringTransform::VT_VALUE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for KeyValueStringTransform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Transform>>("value", Self::VT_VALUE, true)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueStringTransformArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<Transform<'a>>>,
}
impl<'a> Default for KeyValueStringTransformArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueStringTransformArgs {
      key: None, // required field
      value: None, // required field
    }
  }
}

pub struct KeyValueStringTransformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueStringTransformBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValueStringTransform::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Transform<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transform>>(KeyValueStringTransform::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueStringTransformBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueStringTransformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValueStringTransform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValueStringTransform::VT_KEY,"key");
    self.fbb_.required(o, KeyValueStringTransform::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValueStringTransform<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValueStringTransform");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum SourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Source<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Source<'a> {
  type Inner = Source<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Source<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Source { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SourceArgs<'args>
  ) -> flatbuffers::WIPOffset<Source<'bldr>> {
    let mut builder = SourceBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Source::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Source::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Source::VT_TYPE_, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Source<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, true)?
     .finish();
    Ok(())
  }
}
pub struct SourceArgs<'a> {
    pub id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    SourceArgs {
      id: 0,
      name: None, // required field
      type_: None, // required field
    }
  }
}

pub struct SourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Source::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Source::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Source::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Source<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Source::VT_NAME,"name");
    self.fbb_.required(o, Source::VT_TYPE_,"type_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Source<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Source");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum DestinationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Destination<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Destination<'a> {
  type Inner = Destination<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Destination<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Destination { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DestinationArgs<'args>
  ) -> flatbuffers::WIPOffset<Destination<'bldr>> {
    let mut builder = DestinationBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Destination::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Destination::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Destination::VT_TYPE_, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Destination<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, true)?
     .finish();
    Ok(())
  }
}
pub struct DestinationArgs<'a> {
    pub id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DestinationArgs<'a> {
  #[inline]
  fn default() -> Self {
    DestinationArgs {
      id: 0,
      name: None, // required field
      type_: None, // required field
    }
  }
}

pub struct DestinationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DestinationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Destination::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Destination::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Destination::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DestinationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DestinationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Destination<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Destination::VT_NAME,"name");
    self.fbb_.required(o, Destination::VT_TYPE_,"type_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Destination<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Destination");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum KeyValueU64SourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValueU64Source<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValueU64Source<'a> {
  type Inner = KeyValueU64Source<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValueU64Source<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValueU64Source { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueU64SourceArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValueU64Source<'bldr>> {
    let mut builder = KeyValueU64SourceBuilder::new(_fbb);
    builder.add_key(args.key);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(KeyValueU64Source::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Source<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Source>>(KeyValueU64Source::VT_VALUE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for KeyValueU64Source<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Source>>("value", Self::VT_VALUE, true)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueU64SourceArgs<'a> {
    pub key: u64,
    pub value: Option<flatbuffers::WIPOffset<Source<'a>>>,
}
impl<'a> Default for KeyValueU64SourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueU64SourceArgs {
      key: 0,
      value: None, // required field
    }
  }
}

pub struct KeyValueU64SourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueU64SourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: u64) {
    self.fbb_.push_slot::<u64>(KeyValueU64Source::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Source<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Source>>(KeyValueU64Source::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueU64SourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueU64SourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValueU64Source<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValueU64Source::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValueU64Source<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValueU64Source");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum KeyValueU64DestinationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValueU64Destination<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValueU64Destination<'a> {
  type Inner = KeyValueU64Destination<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValueU64Destination<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValueU64Destination { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueU64DestinationArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValueU64Destination<'bldr>> {
    let mut builder = KeyValueU64DestinationBuilder::new(_fbb);
    builder.add_key(args.key);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(KeyValueU64Destination::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Destination<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Destination>>(KeyValueU64Destination::VT_VALUE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for KeyValueU64Destination<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Destination>>("value", Self::VT_VALUE, true)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueU64DestinationArgs<'a> {
    pub key: u64,
    pub value: Option<flatbuffers::WIPOffset<Destination<'a>>>,
}
impl<'a> Default for KeyValueU64DestinationArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueU64DestinationArgs {
      key: 0,
      value: None, // required field
    }
  }
}

pub struct KeyValueU64DestinationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueU64DestinationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: u64) {
    self.fbb_.push_slot::<u64>(KeyValueU64Destination::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Destination<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Destination>>(KeyValueU64Destination::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueU64DestinationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueU64DestinationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValueU64Destination<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValueU64Destination::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValueU64Destination<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValueU64Destination");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum PlanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Plan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Plan<'a> {
  type Inner = Plan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Plan<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TEMPLATE: flatbuffers::VOffsetT = 8;
  pub const VT_LINES: flatbuffers::VOffsetT = 10;
  pub const VT_STATIONS: flatbuffers::VOffsetT = 12;
  pub const VT_STATIONS_TO_IN_OUTS: flatbuffers::VOffsetT = 14;
  pub const VT_SOURCES: flatbuffers::VOffsetT = 16;
  pub const VT_DESTINATIONS: flatbuffers::VOffsetT = 18;
  pub const VT_STATUS: flatbuffers::VOffsetT = 20;
  pub const VT_TRANSFORMS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Plan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlanArgs<'args>
  ) -> flatbuffers::WIPOffset<Plan<'bldr>> {
    let mut builder = PlanBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.transforms { builder.add_transforms(x); }
    if let Some(x) = args.destinations { builder.add_destinations(x); }
    if let Some(x) = args.sources { builder.add_sources(x); }
    if let Some(x) = args.stations_to_in_outs { builder.add_stations_to_in_outs(x); }
    if let Some(x) = args.stations { builder.add_stations(x); }
    if let Some(x) = args.lines { builder.add_lines(x); }
    if let Some(x) = args.template { builder.add_template(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Plan::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Plan::VT_NAME, None)}
  }
  #[inline]
  pub fn template(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Plan::VT_TEMPLATE, None)}
  }
  #[inline]
  pub fn lines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64VecU64<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64VecU64>>>>(Plan::VT_LINES, None)}
  }
  #[inline]
  pub fn stations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Station<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Station>>>>(Plan::VT_STATIONS, None)}
  }
  #[inline]
  pub fn stations_to_in_outs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64VecU64<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64VecU64>>>>(Plan::VT_STATIONS_TO_IN_OUTS, None)}
  }
  #[inline]
  pub fn sources(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Source<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Source>>>>(Plan::VT_SOURCES, None)}
  }
  #[inline]
  pub fn destinations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Destination<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Destination>>>>(Plan::VT_DESTINATIONS, None)}
  }
  #[inline]
  pub fn status(&self) -> PlanStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlanStatus>(Plan::VT_STATUS, Some(PlanStatus::Running)).unwrap()}
  }
  #[inline]
  pub fn transforms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueStringTransform<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueStringTransform>>>>(Plan::VT_TRANSFORMS, None)}
  }
}

impl flatbuffers::Verifiable for Plan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("template", Self::VT_TEMPLATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValueU64VecU64>>>>("lines", Self::VT_LINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValueU64Station>>>>("stations", Self::VT_STATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValueU64VecU64>>>>("stations_to_in_outs", Self::VT_STATIONS_TO_IN_OUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValueU64Source>>>>("sources", Self::VT_SOURCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValueU64Destination>>>>("destinations", Self::VT_DESTINATIONS, false)?
     .visit_field::<PlanStatus>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValueStringTransform>>>>("transforms", Self::VT_TRANSFORMS, false)?
     .finish();
    Ok(())
  }
}
pub struct PlanArgs<'a> {
    pub id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64VecU64<'a>>>>>,
    pub stations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Station<'a>>>>>,
    pub stations_to_in_outs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64VecU64<'a>>>>>,
    pub sources: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Source<'a>>>>>,
    pub destinations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueU64Destination<'a>>>>>,
    pub status: PlanStatus,
    pub transforms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValueStringTransform<'a>>>>>,
}
impl<'a> Default for PlanArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlanArgs {
      id: 0,
      name: None,
      template: None,
      lines: None,
      stations: None,
      stations_to_in_outs: None,
      sources: None,
      destinations: None,
      status: PlanStatus::Running,
      transforms: None,
    }
  }
}

pub struct PlanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Plan::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_NAME, name);
  }
  #[inline]
  pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_TEMPLATE, template);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValueU64VecU64<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_LINES, lines);
  }
  #[inline]
  pub fn add_stations(&mut self, stations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValueU64Station<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_STATIONS, stations);
  }
  #[inline]
  pub fn add_stations_to_in_outs(&mut self, stations_to_in_outs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValueU64VecU64<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_STATIONS_TO_IN_OUTS, stations_to_in_outs);
  }
  #[inline]
  pub fn add_sources(&mut self, sources: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValueU64Source<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_SOURCES, sources);
  }
  #[inline]
  pub fn add_destinations(&mut self, destinations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValueU64Destination<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_DESTINATIONS, destinations);
  }
  #[inline]
  pub fn add_status(&mut self, status: PlanStatus) {
    self.fbb_.push_slot::<PlanStatus>(Plan::VT_STATUS, status, PlanStatus::Running);
  }
  #[inline]
  pub fn add_transforms(&mut self, transforms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValueStringTransform<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plan::VT_TRANSFORMS, transforms);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Plan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Plan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Plan");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("template", &self.template());
      ds.field("lines", &self.lines());
      ds.field("stations", &self.stations());
      ds.field("stations_to_in_outs", &self.stations_to_in_outs());
      ds.field("sources", &self.sources());
      ds.field("destinations", &self.destinations());
      ds.field("status", &self.status());
      ds.field("transforms", &self.transforms());
      ds.finish()
  }
}
pub enum PlansOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Plans<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Plans<'a> {
  type Inner = Plans<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Plans<'a> {
  pub const VT_PLANS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Plans { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlansArgs<'args>
  ) -> flatbuffers::WIPOffset<Plans<'bldr>> {
    let mut builder = PlansBuilder::new(_fbb);
    if let Some(x) = args.plans { builder.add_plans(x); }
    builder.finish()
  }


  #[inline]
  pub fn plans(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Plan<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Plan>>>>(Plans::VT_PLANS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Plans<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Plan>>>>("plans", Self::VT_PLANS, true)?
     .finish();
    Ok(())
  }
}
pub struct PlansArgs<'a> {
    pub plans: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Plan<'a>>>>>,
}
impl<'a> Default for PlansArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlansArgs {
      plans: None, // required field
    }
  }
}

pub struct PlansBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlansBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plans(&mut self, plans: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Plan<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Plans::VT_PLANS, plans);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlansBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlansBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Plans<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Plans::VT_PLANS,"plans");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Plans<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Plans");
      ds.field("plans", &self.plans());
      ds.finish()
  }
}
pub enum NullOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Null<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Null<'a> {
  type Inner = Null<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Null<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Null { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args NullArgs
  ) -> flatbuffers::WIPOffset<Null<'bldr>> {
    let mut builder = NullBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Null<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NullArgs {
}
impl<'a> Default for NullArgs {
  #[inline]
  fn default() -> Self {
    NullArgs {
    }
  }
}

pub struct NullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NullBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Null<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Null<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Null");
      ds.finish()
  }
}
pub enum TimeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Time<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Time<'a> {
  type Inner = Time<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Time<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Time { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimeArgs
  ) -> flatbuffers::WIPOffset<Time<'bldr>> {
    let mut builder = TimeBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Time::VT_DATA, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Time<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TimeArgs {
    pub data: i64,
}
impl<'a> Default for TimeArgs {
  #[inline]
  fn default() -> Self {
    TimeArgs {
      data: 0,
    }
  }
}

pub struct TimeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: i64) {
    self.fbb_.push_slot::<i64>(Time::VT_DATA, data, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TimeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Time<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Time<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Time");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum BoolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bool<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bool<'a> {
  type Inner = Bool<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Bool<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Bool { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoolArgs
  ) -> flatbuffers::WIPOffset<Bool<'bldr>> {
    let mut builder = BoolBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Bool::VT_DATA, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Bool<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BoolArgs {
    pub data: bool,
}
impl<'a> Default for BoolArgs {
  #[inline]
  fn default() -> Self {
    BoolArgs {
      data: false,
    }
  }
}

pub struct BoolBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoolBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: bool) {
    self.fbb_.push_slot::<bool>(Bool::VT_DATA, data, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoolBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoolBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bool<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Bool<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Bool");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum TextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Text<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Text<'a> {
  type Inner = Text<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Text<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Text { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextArgs<'args>
  ) -> flatbuffers::WIPOffset<Text<'bldr>> {
    let mut builder = TextBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Text::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Text<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct TextArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TextArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextArgs {
      data: None, // required field
    }
  }
}

pub struct TextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Text::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Text<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Text::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Text<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Text");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum IntegerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Integer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Integer<'a> {
  type Inner = Integer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Integer<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Integer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntegerArgs
  ) -> flatbuffers::WIPOffset<Integer<'bldr>> {
    let mut builder = IntegerBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Integer::VT_DATA, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Integer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct IntegerArgs {
    pub data: i64,
}
impl<'a> Default for IntegerArgs {
  #[inline]
  fn default() -> Self {
    IntegerArgs {
      data: 0,
    }
  }
}

pub struct IntegerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntegerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: i64) {
    self.fbb_.push_slot::<i64>(Integer::VT_DATA, data, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntegerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntegerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Integer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Integer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Integer");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum FloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float<'a> {
  type Inner = Float<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Float<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Float { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatArgs
  ) -> flatbuffers::WIPOffset<Float<'bldr>> {
    let mut builder = FloatBuilder::new(_fbb);
    builder.add_data(args.data);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Float::VT_DATA, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Float<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatArgs {
    pub data: f32,
}
impl<'a> Default for FloatArgs {
  #[inline]
  fn default() -> Self {
    FloatArgs {
      data: 0.0,
    }
  }
}

pub struct FloatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: f32) {
    self.fbb_.push_slot::<f32>(Float::VT_DATA, data, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Float<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Float");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum ValueWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueWrapper<'a> {
  type Inner = ValueWrapper<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ValueWrapper<'a> {
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ValueWrapper { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValueWrapperArgs
  ) -> flatbuffers::WIPOffset<ValueWrapper<'bldr>> {
    let mut builder = ValueWrapperBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn data_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(ValueWrapper::VT_DATA_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ValueWrapper::VT_DATA, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_null(&self) -> Option<Null<'a>> {
    if self.data_type() == Value::Null {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Null::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_text(&self) -> Option<Text<'a>> {
    if self.data_type() == Value::Text {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Text::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_bool(&self) -> Option<Bool<'a>> {
    if self.data_type() == Value::Bool {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Bool::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_integer(&self) -> Option<Integer<'a>> {
    if self.data_type() == Value::Integer {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Integer::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_float(&self) -> Option<Float<'a>> {
    if self.data_type() == Value::Float {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Float::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_list(&self) -> Option<List<'a>> {
    if self.data_type() == Value::List {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { List::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_document(&self) -> Option<Document<'a>> {
    if self.data_type() == Value::Document {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Document::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_time(&self) -> Option<Time<'a>> {
    if self.data_type() == Value::Time {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Time::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ValueWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Value, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, true, |key, v, pos| {
        match key {
          Value::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Value::Null", pos),
          Value::Text => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Text>>("Value::Text", pos),
          Value::Bool => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Bool>>("Value::Bool", pos),
          Value::Integer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Integer>>("Value::Integer", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Value::List", pos),
          Value::Document => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Document>>("Value::Document", pos),
          Value::Time => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Time>>("Value::Time", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ValueWrapperArgs {
    pub data_type: Value,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ValueWrapperArgs {
  #[inline]
  fn default() -> Self {
    ValueWrapperArgs {
      data_type: Value::NONE,
      data: None, // required field
    }
  }
}

pub struct ValueWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueWrapperBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data_type(&mut self, data_type: Value) {
    self.fbb_.push_slot::<Value>(ValueWrapper::VT_DATA_TYPE, data_type, Value::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValueWrapper::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueWrapperBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValueWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValueWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ValueWrapper::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ValueWrapper<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ValueWrapper");
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        Value::Null => {
          if let Some(x) = self.data_as_null() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Text => {
          if let Some(x) = self.data_as_text() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Bool => {
          if let Some(x) = self.data_as_bool() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Integer => {
          if let Some(x) = self.data_as_integer() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.data_as_float() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::List => {
          if let Some(x) = self.data_as_list() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Document => {
          if let Some(x) = self.data_as_document() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Time => {
          if let Some(x) = self.data_as_time() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.finish()
  }
}
pub enum ListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct List<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for List<'a> {
  type Inner = List<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> List<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    List { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ListArgs<'args>
  ) -> flatbuffers::WIPOffset<List<'bldr>> {
    let mut builder = ListBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper>>>>(List::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for List<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueWrapper>>>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct ListArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>>>>,
}
impl<'a> Default for ListArgs<'a> {
  #[inline]
  fn default() -> Self {
    ListArgs {
      data: None, // required field
    }
  }
}

pub struct ListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ListBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(List::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ListBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<List<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, List::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for List<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("List");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValue<'a> {
  pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_VALUES_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_VALUES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueArgs
  ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_values_type(args.values_type);
    builder.add_key_type(args.key_type);
    builder.finish()
  }


  #[inline]
  pub fn key_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(KeyValue::VT_KEY_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(KeyValue::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn values_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(KeyValue::VT_VALUES_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn values(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(KeyValue::VT_VALUES, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_null(&self) -> Option<Null<'a>> {
    if self.key_type() == Value::Null {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Null::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_text(&self) -> Option<Text<'a>> {
    if self.key_type() == Value::Text {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Text::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_bool(&self) -> Option<Bool<'a>> {
    if self.key_type() == Value::Bool {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Bool::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_integer(&self) -> Option<Integer<'a>> {
    if self.key_type() == Value::Integer {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Integer::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_float(&self) -> Option<Float<'a>> {
    if self.key_type() == Value::Float {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Float::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_list(&self) -> Option<List<'a>> {
    if self.key_type() == Value::List {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { List::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_document(&self) -> Option<Document<'a>> {
    if self.key_type() == Value::Document {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Document::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn key_as_time(&self) -> Option<Time<'a>> {
    if self.key_type() == Value::Time {
      let u = self.key();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Time::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_null(&self) -> Option<Null<'a>> {
    if self.values_type() == Value::Null {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Null::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_text(&self) -> Option<Text<'a>> {
    if self.values_type() == Value::Text {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Text::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_bool(&self) -> Option<Bool<'a>> {
    if self.values_type() == Value::Bool {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Bool::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_integer(&self) -> Option<Integer<'a>> {
    if self.values_type() == Value::Integer {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Integer::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_float(&self) -> Option<Float<'a>> {
    if self.values_type() == Value::Float {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Float::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_list(&self) -> Option<List<'a>> {
    if self.values_type() == Value::List {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { List::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_document(&self) -> Option<Document<'a>> {
    if self.values_type() == Value::Document {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Document::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn values_as_time(&self) -> Option<Time<'a>> {
    if self.values_type() == Value::Time {
      let u = self.values();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Time::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for KeyValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Value, _>("key_type", Self::VT_KEY_TYPE, "key", Self::VT_KEY, true, |key, v, pos| {
        match key {
          Value::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Value::Null", pos),
          Value::Text => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Text>>("Value::Text", pos),
          Value::Bool => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Bool>>("Value::Bool", pos),
          Value::Integer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Integer>>("Value::Integer", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Value::List", pos),
          Value::Document => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Document>>("Value::Document", pos),
          Value::Time => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Time>>("Value::Time", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Value, _>("values_type", Self::VT_VALUES_TYPE, "values", Self::VT_VALUES, true, |key, v, pos| {
        match key {
          Value::Null => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Null>>("Value::Null", pos),
          Value::Text => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Text>>("Value::Text", pos),
          Value::Bool => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Bool>>("Value::Bool", pos),
          Value::Integer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Integer>>("Value::Integer", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::List => v.verify_union_variant::<flatbuffers::ForwardsUOffset<List>>("Value::List", pos),
          Value::Document => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Document>>("Value::Document", pos),
          Value::Time => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Time>>("Value::Time", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct KeyValueArgs {
    pub key_type: Value,
    pub key: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub values_type: Value,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for KeyValueArgs {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key_type: Value::NONE,
      key: None, // required field
      values_type: Value::NONE,
      values: None, // required field
    }
  }
}

pub struct KeyValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_type(&mut self, key_type: Value) {
    self.fbb_.push_slot::<Value>(KeyValue::VT_KEY_TYPE, key_type, Value::NONE);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_values_type(&mut self, values_type: Value) {
    self.fbb_.push_slot::<Value>(KeyValue::VT_VALUES_TYPE, values_type, Value::NONE);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValue::VT_KEY,"key");
    self.fbb_.required(o, KeyValue::VT_VALUES,"values");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key_type", &self.key_type());
      match self.key_type() {
        Value::Null => {
          if let Some(x) = self.key_as_null() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Text => {
          if let Some(x) = self.key_as_text() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Bool => {
          if let Some(x) = self.key_as_bool() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Integer => {
          if let Some(x) = self.key_as_integer() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.key_as_float() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::List => {
          if let Some(x) = self.key_as_list() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Document => {
          if let Some(x) = self.key_as_document() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Time => {
          if let Some(x) = self.key_as_time() {
            ds.field("key", &x)
          } else {
            ds.field("key", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("key", &x)
        },
      };
      ds.field("values_type", &self.values_type());
      match self.values_type() {
        Value::Null => {
          if let Some(x) = self.values_as_null() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Text => {
          if let Some(x) = self.values_as_text() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Bool => {
          if let Some(x) = self.values_as_bool() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Integer => {
          if let Some(x) = self.values_as_integer() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.values_as_float() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::List => {
          if let Some(x) = self.values_as_list() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Document => {
          if let Some(x) = self.values_as_document() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Time => {
          if let Some(x) = self.values_as_time() {
            ds.field("values", &x)
          } else {
            ds.field("values", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("values", &x)
        },
      };
      ds.finish()
  }
}
pub enum DocumentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Document<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Document<'a> {
  type Inner = Document<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Document<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Document { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DocumentArgs<'args>
  ) -> flatbuffers::WIPOffset<Document<'bldr>> {
    let mut builder = DocumentBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Document::VT_DATA, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Document<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("data", Self::VT_DATA, true)?
     .finish();
    Ok(())
  }
}
pub struct DocumentArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for DocumentArgs<'a> {
  #[inline]
  fn default() -> Self {
    DocumentArgs {
      data: None, // required field
    }
  }
}

pub struct DocumentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DocumentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Document::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DocumentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DocumentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Document<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Document::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Document<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Document");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum TrainOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Train<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Train<'a> {
  type Inner = Train<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Train<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_TOPIC: flatbuffers::VOffsetT = 6;
  pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Train { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TrainArgs<'args>
  ) -> flatbuffers::WIPOffset<Train<'bldr>> {
    let mut builder = TrainBuilder::new(_fbb);
    if let Some(x) = args.event_time { builder.add_event_time(x); }
    if let Some(x) = args.topic { builder.add_topic(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper>>>>(Train::VT_VALUES, None).unwrap()}
  }
  #[inline]
  pub fn topic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Train::VT_TOPIC, None)}
  }
  #[inline]
  pub fn event_time(&self) -> Option<Time<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Time>>(Train::VT_EVENT_TIME, None)}
  }
}

impl flatbuffers::Verifiable for Train<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ValueWrapper>>>>("values", Self::VT_VALUES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topic", Self::VT_TOPIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Time>>("event_time", Self::VT_EVENT_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct TrainArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ValueWrapper<'a>>>>>,
    pub topic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time: Option<flatbuffers::WIPOffset<Time<'a>>>,
}
impl<'a> Default for TrainArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrainArgs {
      values: None, // required field
      topic: None,
      event_time: None,
    }
  }
}

pub struct TrainBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TrainBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ValueWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Train::VT_VALUES, values);
  }
  #[inline]
  pub fn add_topic(&mut self, topic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Train::VT_TOPIC, topic);
  }
  #[inline]
  pub fn add_event_time(&mut self, event_time: flatbuffers::WIPOffset<Time<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Time>>(Train::VT_EVENT_TIME, event_time);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TrainBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TrainBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Train<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Train::VT_VALUES,"values");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Train<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Train");
      ds.field("values", &self.values());
      ds.field("topic", &self.topic());
      ds.field("event_time", &self.event_time());
      ds.finish()
  }
}
pub enum ErrorStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ErrorStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ErrorStatus<'a> {
  type Inner = ErrorStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ErrorStatus<'a> {
  pub const VT_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_MSG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ErrorStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorStatusArgs<'args>
  ) -> flatbuffers::WIPOffset<ErrorStatus<'bldr>> {
    let mut builder = ErrorStatusBuilder::new(_fbb);
    if let Some(x) = args.msg { builder.add_msg(x); }
    builder.add_code(args.code);
    builder.finish()
  }


  #[inline]
  pub fn code(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ErrorStatus::VT_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn msg(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ErrorStatus::VT_MSG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ErrorStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("code", Self::VT_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msg", Self::VT_MSG, true)?
     .finish();
    Ok(())
  }
}
pub struct ErrorStatusArgs<'a> {
    pub code: u32,
    pub msg: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorStatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorStatusArgs {
      code: 0,
      msg: None, // required field
    }
  }
}

pub struct ErrorStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code(&mut self, code: u32) {
    self.fbb_.push_slot::<u32>(ErrorStatus::VT_CODE, code, 0);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ErrorStatus::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ErrorStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ErrorStatus::VT_MSG,"msg");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ErrorStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ErrorStatus");
      ds.field("code", &self.code());
      ds.field("msg", &self.msg());
      ds.finish()
  }
}
pub enum OkStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OkStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OkStatus<'a> {
  type Inner = OkStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OkStatus<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OkStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args OkStatusArgs
  ) -> flatbuffers::WIPOffset<OkStatus<'bldr>> {
    let mut builder = OkStatusBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for OkStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct OkStatusArgs {
}
impl<'a> Default for OkStatusArgs {
  #[inline]
  fn default() -> Self {
    OkStatusArgs {
    }
  }
}

pub struct OkStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OkStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OkStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OkStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OkStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OkStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OkStatus");
      ds.finish()
  }
}
pub enum BindRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BindRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BindRequest<'a> {
  type Inner = BindRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BindRequest<'a> {
  pub const VT_PLAN_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STOP_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BindRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BindRequestArgs
  ) -> flatbuffers::WIPOffset<BindRequest<'bldr>> {
    let mut builder = BindRequestBuilder::new(_fbb);
    builder.add_stop_id(args.stop_id);
    builder.add_plan_id(args.plan_id);
    builder.finish()
  }


  #[inline]
  pub fn plan_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BindRequest::VT_PLAN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stop_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BindRequest::VT_STOP_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BindRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("plan_id", Self::VT_PLAN_ID, false)?
     .visit_field::<u64>("stop_id", Self::VT_STOP_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct BindRequestArgs {
    pub plan_id: u64,
    pub stop_id: u64,
}
impl<'a> Default for BindRequestArgs {
  #[inline]
  fn default() -> Self {
    BindRequestArgs {
      plan_id: 0,
      stop_id: 0,
    }
  }
}

pub struct BindRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BindRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plan_id(&mut self, plan_id: u64) {
    self.fbb_.push_slot::<u64>(BindRequest::VT_PLAN_ID, plan_id, 0);
  }
  #[inline]
  pub fn add_stop_id(&mut self, stop_id: u64) {
    self.fbb_.push_slot::<u64>(BindRequest::VT_STOP_ID, stop_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BindRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BindRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BindRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BindRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BindRequest");
      ds.field("plan_id", &self.plan_id());
      ds.field("stop_id", &self.stop_id());
      ds.finish()
  }
}
pub enum BindResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BindResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BindResponse<'a> {
  type Inner = BindResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BindResponse<'a> {
  pub const VT_PLAN_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STOP_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BindResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BindResponseArgs
  ) -> flatbuffers::WIPOffset<BindResponse<'bldr>> {
    let mut builder = BindResponseBuilder::new(_fbb);
    builder.add_stop_id(args.stop_id);
    builder.add_plan_id(args.plan_id);
    builder.finish()
  }


  #[inline]
  pub fn plan_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BindResponse::VT_PLAN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stop_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BindResponse::VT_STOP_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BindResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("plan_id", Self::VT_PLAN_ID, false)?
     .visit_field::<u64>("stop_id", Self::VT_STOP_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct BindResponseArgs {
    pub plan_id: u64,
    pub stop_id: u64,
}
impl<'a> Default for BindResponseArgs {
  #[inline]
  fn default() -> Self {
    BindResponseArgs {
      plan_id: 0,
      stop_id: 0,
    }
  }
}

pub struct BindResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BindResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plan_id(&mut self, plan_id: u64) {
    self.fbb_.push_slot::<u64>(BindResponse::VT_PLAN_ID, plan_id, 0);
  }
  #[inline]
  pub fn add_stop_id(&mut self, stop_id: u64) {
    self.fbb_.push_slot::<u64>(BindResponse::VT_STOP_ID, stop_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BindResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BindResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BindResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BindResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BindResponse");
      ds.field("plan_id", &self.plan_id());
      ds.field("stop_id", &self.stop_id());
      ds.finish()
  }
}
pub enum UnbindRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnbindRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnbindRequest<'a> {
  type Inner = UnbindRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnbindRequest<'a> {
  pub const VT_PLAN_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STOP_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnbindRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnbindRequestArgs
  ) -> flatbuffers::WIPOffset<UnbindRequest<'bldr>> {
    let mut builder = UnbindRequestBuilder::new(_fbb);
    builder.add_stop_id(args.stop_id);
    builder.add_plan_id(args.plan_id);
    builder.finish()
  }


  #[inline]
  pub fn plan_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UnbindRequest::VT_PLAN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stop_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UnbindRequest::VT_STOP_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UnbindRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("plan_id", Self::VT_PLAN_ID, false)?
     .visit_field::<u64>("stop_id", Self::VT_STOP_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct UnbindRequestArgs {
    pub plan_id: u64,
    pub stop_id: u64,
}
impl<'a> Default for UnbindRequestArgs {
  #[inline]
  fn default() -> Self {
    UnbindRequestArgs {
      plan_id: 0,
      stop_id: 0,
    }
  }
}

pub struct UnbindRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnbindRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plan_id(&mut self, plan_id: u64) {
    self.fbb_.push_slot::<u64>(UnbindRequest::VT_PLAN_ID, plan_id, 0);
  }
  #[inline]
  pub fn add_stop_id(&mut self, stop_id: u64) {
    self.fbb_.push_slot::<u64>(UnbindRequest::VT_STOP_ID, stop_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnbindRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnbindRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnbindRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnbindRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnbindRequest");
      ds.field("plan_id", &self.plan_id());
      ds.field("stop_id", &self.stop_id());
      ds.finish()
  }
}
pub enum UnbindResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnbindResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnbindResponse<'a> {
  type Inner = UnbindResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnbindResponse<'a> {
  pub const VT_PLAN_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STOP_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnbindResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnbindResponseArgs
  ) -> flatbuffers::WIPOffset<UnbindResponse<'bldr>> {
    let mut builder = UnbindResponseBuilder::new(_fbb);
    builder.add_stop_id(args.stop_id);
    builder.add_plan_id(args.plan_id);
    builder.finish()
  }


  #[inline]
  pub fn plan_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UnbindResponse::VT_PLAN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stop_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UnbindResponse::VT_STOP_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UnbindResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("plan_id", Self::VT_PLAN_ID, false)?
     .visit_field::<u64>("stop_id", Self::VT_STOP_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct UnbindResponseArgs {
    pub plan_id: u64,
    pub stop_id: u64,
}
impl<'a> Default for UnbindResponseArgs {
  #[inline]
  fn default() -> Self {
    UnbindResponseArgs {
      plan_id: 0,
      stop_id: 0,
    }
  }
}

pub struct UnbindResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnbindResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plan_id(&mut self, plan_id: u64) {
    self.fbb_.push_slot::<u64>(UnbindResponse::VT_PLAN_ID, plan_id, 0);
  }
  #[inline]
  pub fn add_stop_id(&mut self, stop_id: u64) {
    self.fbb_.push_slot::<u64>(UnbindResponse::VT_STOP_ID, stop_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnbindResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnbindResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnbindResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnbindResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnbindResponse");
      ds.field("plan_id", &self.plan_id());
      ds.field("stop_id", &self.stop_id());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Message<'a> {
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;
  pub const VT_STATUS_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_STATUS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessageArgs
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_status_type(args.status_type);
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn data_type(&self) -> Payload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Payload>(Message::VT_DATA_TYPE, Some(Payload::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_DATA, None).unwrap()}
  }
  #[inline]
  pub fn status_type(&self) -> Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Status>(Message::VT_STATUS_TYPE, Some(Status::NONE)).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_STATUS, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_create(&self) -> Option<Create<'a>> {
    if self.data_type() == Payload::Create {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Create::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_get(&self) -> Option<Get<'a>> {
    if self.data_type() == Payload::Get {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Get::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_train(&self) -> Option<Train<'a>> {
    if self.data_type() == Payload::Train {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Train::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_catalog(&self) -> Option<Catalog<'a>> {
    if self.data_type() == Payload::Catalog {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Catalog::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_register_request(&self) -> Option<RegisterRequest<'a>> {
    if self.data_type() == Payload::RegisterRequest {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RegisterRequest::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_register_response(&self) -> Option<RegisterResponse<'a>> {
    if self.data_type() == Payload::RegisterResponse {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RegisterResponse::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_bind_request(&self) -> Option<BindRequest<'a>> {
    if self.data_type() == Payload::BindRequest {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { BindRequest::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_bind_response(&self) -> Option<BindResponse<'a>> {
    if self.data_type() == Payload::BindResponse {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { BindResponse::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_unbind_request(&self) -> Option<UnbindRequest<'a>> {
    if self.data_type() == Payload::UnbindRequest {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UnbindRequest::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_unbind_response(&self) -> Option<UnbindResponse<'a>> {
    if self.data_type() == Payload::UnbindResponse {
      let u = self.data();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UnbindResponse::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn status_as_ok_status(&self) -> Option<OkStatus<'a>> {
    if self.status_type() == Status::OkStatus {
      let u = self.status();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { OkStatus::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn status_as_error_status(&self) -> Option<ErrorStatus<'a>> {
    if self.status_type() == Status::ErrorStatus {
      let u = self.status();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ErrorStatus::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Payload, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, true, |key, v, pos| {
        match key {
          Payload::Create => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Create>>("Payload::Create", pos),
          Payload::Get => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Get>>("Payload::Get", pos),
          Payload::Train => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Train>>("Payload::Train", pos),
          Payload::Catalog => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Catalog>>("Payload::Catalog", pos),
          Payload::RegisterRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegisterRequest>>("Payload::RegisterRequest", pos),
          Payload::RegisterResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegisterResponse>>("Payload::RegisterResponse", pos),
          Payload::BindRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BindRequest>>("Payload::BindRequest", pos),
          Payload::BindResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BindResponse>>("Payload::BindResponse", pos),
          Payload::UnbindRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnbindRequest>>("Payload::UnbindRequest", pos),
          Payload::UnbindResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnbindResponse>>("Payload::UnbindResponse", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Status, _>("status_type", Self::VT_STATUS_TYPE, "status", Self::VT_STATUS, true, |key, v, pos| {
        match key {
          Status::OkStatus => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OkStatus>>("Status::OkStatus", pos),
          Status::ErrorStatus => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ErrorStatus>>("Status::ErrorStatus", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs {
    pub data_type: Payload,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub status_type: Status,
    pub status: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      data_type: Payload::NONE,
      data: None, // required field
      status_type: Status::NONE,
      status: None, // required field
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data_type(&mut self, data_type: Payload) {
    self.fbb_.push_slot::<Payload>(Message::VT_DATA_TYPE, data_type, Payload::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_DATA, data);
  }
  #[inline]
  pub fn add_status_type(&mut self, status_type: Status) {
    self.fbb_.push_slot::<Status>(Message::VT_STATUS_TYPE, status_type, Status::NONE);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_STATUS, status);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Message::VT_DATA,"data");
    self.fbb_.required(o, Message::VT_STATUS,"status");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        Payload::Create => {
          if let Some(x) = self.data_as_create() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Get => {
          if let Some(x) = self.data_as_get() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Train => {
          if let Some(x) = self.data_as_train() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::Catalog => {
          if let Some(x) = self.data_as_catalog() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::RegisterRequest => {
          if let Some(x) = self.data_as_register_request() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::RegisterResponse => {
          if let Some(x) = self.data_as_register_response() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::BindRequest => {
          if let Some(x) = self.data_as_bind_request() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::BindResponse => {
          if let Some(x) = self.data_as_bind_response() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::UnbindRequest => {
          if let Some(x) = self.data_as_unbind_request() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Payload::UnbindResponse => {
          if let Some(x) = self.data_as_unbind_response() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.field("status_type", &self.status_type());
      match self.status_type() {
        Status::OkStatus => {
          if let Some(x) = self.status_as_ok_status() {
            ds.field("status", &x)
          } else {
            ds.field("status", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Status::ErrorStatus => {
          if let Some(x) = self.status_as_error_status() {
            ds.field("status", &x)
          } else {
            ds.field("status", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("status", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod protocol

